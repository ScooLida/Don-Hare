
# ==============================================================================
# ПОИСК ДАННЫХ (GREP)
# ==============================================================================

# Найти TaxID гриба в отчете
grep "153531" report.txt

# Найти гриб во всех отчетах и показать имена файлов
grep -H "153531" results/*_report.txt

# Посчитать, сколько раз гриб встретился во всех файлах
grep -c "153531" results/*.txt

# ==============================================================================
#  Инфа
# ==============================================================================
# Сделать файл программой (дать право на выполнение)

#!/bin/bash
chmod +x run_analysis.sh

./run_analysis.sh # Запустить исполняемый файл из текущей папки
bash run_analysis.sh # Запустить скрипт через интерпретатор (если не хочется делать chmod)
ls -l # Посмотреть текущие права всех файлов в папке

# Создать переменную (ВАЖНО: без пробелов вокруг знака =)
DB_PATH="my_fungi_db"

#все четыре можно без кавычек, но лучше с ними
# Вывести значение переменной в терминал
echo "$DB_PATH"

# Удалить расширение .fastq с конца (результат: sample_01)
echo ${FILE%.fastq}

# Удалить суффикс рида _R1.fastq (результат: sample_01)
echo ${FILE%_R1.fastq}

# Удалить префикс raw_ с начала имени (результат: sample_01.fastq)
echo ${FILE#raw_}


# ==============================================================================
#  ЦИКЛЫ (LOOPS)
# ==============================================================================

# Простейший цикл для обработки всех FASTQ файлов
for file in *.fastq; do echo "Обрабатываю $file"; done

# Поиск файлов и создание папок для каждого (пример в одну строку)
for dir in sample1 sample2; do mkdir -p "$dir"; done # p чтобы не ругалась, если папка есть

# Подать список имен из файла на вход циклу
while read line; do echo "Sample: $line"; done < samples.txt

#Можно подать файл в начале- используется конвейер (pipe |). \\
cat samples.txt | while read line; do
    echo "Sample: $line"
done
#Вариант done < file позволяет менять переменные внутри цикла и использовать их потом.
#Вариант cat file | while) Создает «подпроцесс» (subshell), переменная за пределами цикла она останется прежней

if [[ "$A" == "1" ]]; then echo "Один"; elif [[ "$A" == "2" ]]; then echo "Два"; elif [[ "$A" == "23" ]]; then echo "Два3"; else echo "Много"; fi

#  Условие  ТОГДА (&&)       ИНАЧЕ (||)
[[ "$A" == "$B" ]] && echo "Да" || echo "Нет"

#КОМАНДА_1 && КОМАНДА_2 — Выполнить вторую, только если первая прошла успешно.
#КОМАНДА_1 || КОМАНДА_2 — Выполнить вторую, только если первая ПРОВАЛИЛАСЬ.

# сравнение строк 
#== (равно), != (не равно), -z (строка пуста), -n (строка НЕ пуста), < (меньше/раньше по алфавиту), > (больше/позже по алфавиту)
#Важно: Для знаков < и > всегда используй двойные скобки [[ ]], чтобы Bash не перепутал их с направлением потока данных в файлы.

#Сравнение чисел (используются сокращения):
#   -eq (equal) — равно
#   -ne (not equal) — не равно
#    -gt (greater than) — больше
#   -lt (less than) — меньше
# -le     Меньше или равно (Less or Equal)
[ "$A" -ge "$B" ]    # Больше или равно (Greater or Equal)
echo $? #проверить, успешна ли последняя команда(0 - успех)

-f $FILE	#Существует ли такой файл?
-d $DIR	#Существует ли такая папка?
-s $FILE	#Файл существует и он не пустой?
-z $VAR	#Переменная пустая?
# Проверь файл. Если он ЕСТЬ (&&), напиши "Да". Если НЕТ (||), напиши "Нет".
[ -f "$FILE" ] && echo "Файл существует" || echo "Файла нет"

[ "$F1" -nt "$F2" ]  # True, если файл F1 НОВЕЕ, чем F2 (newer than)


${VAR} # Изолирует имя переменной от соседнего текста.
${VAR%...}# Позволяет менять или обрезать текст внутри переменной.
"{a,b,c}"# Создает список вариантов (генерация путей/имен).
{ cmd;} # Объединяет несколько команд в одну группу.

mkdir {data,results,logs}
#В отличие от квадратных скобок [ ], внутри фигурных скобок { } при группировке команд обязательно ставить точку с запятой ; перед закрывающей скобкой: { echo "Hi"; } — правильно. { echo "Hi" } — ошибка.

# ==============================================================================
#  ПЕРЕНАПРАВЛЕНИЯ (СТРЕЛКИ)
# ==============================================================================

# Направить результат работы программы в файл (перезаписать его)
kraken2 --db my_db reads.fq > output.txt

# Добавить результат в конец существующего файла
echo "Analysis finished at $(date)" >> log.txt


# ==============================================================================
# 6. БЕЗОПАСНОСТЬ И ЗАЩИТА 
# ==============================================================================

# Запретить любое изменение и удаление в папке (только чтение и вход)
chmod -R 555 results/

# Вернуть себе права на запись и удаление
chmod -R 755 results/

# Сделать файл доступным только для владельца (приватность)
chmod 600 private_data.txt
#Владелец | Группа | Все остальные. 
# 0-нет_прав, 1-выполнение, 2-запись, 3-запись+выполнение, 4-чтение, 5-чтение+выполнение, 6-чтение+запись, 7-все_права(rwx)

# Посмотреть свободное место на всех дисках (в ГБ и ТБ)
df -h

# Узнать, на каком диске находится текущая папка
df -h .

# Список всех физических дисков и их разделов
lsblk

# Размер всех файлов и папок в текущей директории
du -sh *

# Узнать полный путь к текущей папке
pwd

# Посмотреть владельца папки и права доступа
ls -ld /home/users/sofa

# Стать суперпользователем (root)
sudo -s

# Сделать пользователя владельцем папки на большом диске
sudo chown -R sofa:sofa /mnt/Storage/data

# Создать ссылку на папку из большого диска в домашнюю директорию
ln -s /mnt/Storage/data /home/users/sofa/big_drive

# Проверить, куда именно ведет созданная ссылка
ls -l /home/users/sofa/big_drive

# Проверить права на запись (создать тестовый файл через ссылку)
touch /home/users/sofa/big_drive/test.txt
